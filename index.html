
# –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π app.js –±–µ–∑ Firebase, —Å WebRTC + Base64
app_js_free = '''// Bunker Game - P2P –≤–µ—Ä—Å–∏—è –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞ (WebRTC + Base64)
class BunkerGame {
    constructor() {
        this.roomId = null;
        this.playerId = null;
        this.playerName = '';
        this.isHost = false;
        this.gameState = null;
        this.players = {};
        this.connections = {};
        this.peer = null;
        this.timerInterval = null;
        this.selectedVote = null;
        
        // PeerJS –∫–æ–Ω—Ñ–∏–≥ (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä—ã)
        this.peerConfig = {
            host: 'peerjs.mirotalk.net',
            port: 443,
            secure: true,
            debug: 1
        };
        
        this.init();
    }

    init() {
        this.checkURLParams();
        this.setupEventListeners();
        
        setTimeout(() => {
            document.getElementById('loadingScreen').style.display = 'none';
        }, 1000);
    }

    checkURLParams() {
        const params = new URLSearchParams(window.location.search);
        const room = params.get('room');
        const data = params.get('data');
        
        if (room && data) {
            // –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ —Å—Å—ã–ª–∫–µ
            try {
                const decoded = JSON.parse(atob(decodeURIComponent(data)));
                this.joinByLink(room, decoded);
            } catch(e) {
                console.error('Invalid link');
            }
        }
    }

    setupEventListeners() {
        document.getElementById('createPlayerName')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.createGame();
        });
        
        document.getElementById('roomCodeInput')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.joinGame();
        });

        document.getElementById('chatInput')?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.sendMessage();
        });

        document.getElementById('roomCodeInput')?.addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
        });
    }

    generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 4; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
    }

    generatePlayerId() {
        return 'p_' + Math.random().toString(36).substr(2, 9);
    }

    async createGame() {
        const name = document.getElementById('createPlayerName').value.trim();
        const maxPlayers = parseInt(document.getElementById('maxPlayers').value);

        if (!name) {
            this.showModal('–û—à–∏–±–∫–∞', '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è');
            return;
        }

        this.playerName = name;
        this.playerId = this.generatePlayerId();
        this.isHost = true;
        this.roomId = this.generateRoomCode();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PeerJS –∫–∞–∫ —Ö–æ—Å—Ç
        this.peer = new Peer(this.roomId, this.peerConfig);
        
        this.peer.on('open', (id) => {
            console.log('Host peer opened:', id);
            
            this.players[this.playerId] = {
                id: this.playerId,
                name: name,
                isHost: true,
                isReady: false,
                avatar: this.generateAvatar(name),
                isAlive: true
            };

            this.gameState = {
                code: this.roomId,
                host: this.playerId,
                maxPlayers: maxPlayers,
                status: 'lobby',
                players: this.players,
                messages: []
            };

            this.showScreen('lobby');
            document.getElementById('displayRoomCode').textContent = this.roomId;
            document.getElementById('hostControls').style.display = 'block';
            this.updatePlayerCount(1, maxPlayers);
            this.updateLobby();

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
            this.generateInviteLink();
        });

        this.peer.on('connection', (conn) => {
            console.log('Player connected:', conn.peer);
            
            conn.on('open', () => {
                this.connections[conn.peer] = conn;
                
                conn.on('data', (data) => {
                    this.handleData(conn.peer, data);
                });

                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–æ–≤–æ–º—É –∏–≥—Ä–æ–∫—É
                conn.send({
                    type: 'init',
                    gameState: this.gameState
                });
            });

            conn.on('close', () => {
                this.handleDisconnect(conn.peer);
            });
        });

        this.peer.on('error', (err) => {
            console.error('Peer error:', err);
            this.showModal('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É: ' + err.message);
        });
    }

    async joinGame() {
        const name = document.getElementById('joinPlayerName').value.trim();
        const code = document.getElementById('roomCodeInput').value.toUpperCase();

        if (!name) {
            this.showModal('–û—à–∏–±–∫–∞', '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è');
            return;
        }

        if (code.length !== 4) {
            this.showModal('–û—à–∏–±–∫–∞', '–í–≤–µ–¥–∏—Ç–µ 4-—Å–∏–º–≤–æ–ª—å–Ω—ã–π –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã');
            return;
        }

        this.playerName = name;
        this.playerId = this.generatePlayerId();
        this.roomId = code;
        this.isHost = false;

        // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Ö–æ—Å—Ç—É
        this.peer = new Peer(this.generatePlayerId(), this.peerConfig);
        
        this.peer.on('open', () => {
            const conn = this.peer.connect(code, {
                reliable: true
            });

            conn.on('open', () => {
                console.log('Connected to host');
                this.connections['host'] = conn;
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–µ–±–µ
                conn.send({
                    type: 'join',
                    player: {
                        id: this.playerId,
                        name: name,
                        isHost: false,
                        isReady: false,
                        avatar: this.generateAvatar(name),
                        isAlive: true
                    }
                });
            });

            conn.on('data', (data) => {
                this.handleData('host', data);
            });

            conn.on('close', () => {
                this.showModal('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ', '–•–æ—Å—Ç –æ—Ç–∫–ª—é—á–∏–ª—Å—è');
                this.returnToMenu();
            });

            conn.on('error', (err) => {
                console.error('Connection error:', err);
                this.showModal('–û—à–∏–±–∫–∞', '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ');
            });
        });

        this.peer.on('error', (err) => {
            console.error('Peer error:', err);
            this.showModal('–û—à–∏–±–∫–∞', '–ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —Ö–æ—Å—Ç offline');
        });
    }

    joinByLink(roomId, data) {
        // –ê–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–∑ —Å—Å—ã–ª–∫–∏
        document.getElementById('joinPlayerName').value = '';
        document.getElementById('roomCodeInput').value = roomId;
        this.showScreen('joinRoom');
        this.showModal('–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ', '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è –∏ –Ω–∞–∂–º–∏—Ç–µ "–í–æ–π—Ç–∏ –≤ –∫–æ–º–Ω–∞—Ç—É"');
    }

    handleData(fromId, data) {
        console.log('Received:', data);

        switch(data.type) {
            case 'init':
                // –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ö–æ—Å—Ç–∞
                this.gameState = data.gameState;
                this.players = data.gameState.players;
                this.showScreen('lobby');
                document.getElementById('displayRoomCode').textContent = this.gameState.code;
                document.getElementById('hostControls').style.display = 'none';
                this.updateLobby();
                break;

            case 'join':
                // –•–æ—Å—Ç –ø–æ–ª—É—á–∞–µ—Ç –Ω–æ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
                if (this.isHost) {
                    this.players[data.player.id] = data.player;
                    this.gameState.players = this.players;
                    this.broadcast({
                        type: 'update',
                        gameState: this.gameState
                    });
                    this.updateLobby();
                }
                break;

            case 'update':
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                this.gameState = data.gameState;
                this.players = data.gameState.players;
                if (this.currentScreen === 'lobby') {
                    this.updateLobby();
                } else if (this.currentScreen === 'gameScreen') {
                    this.handleGameUpdate();
                }
                break;

            case 'start':
                // –ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å
                this.gameState = data.gameState;
                this.showScreen('gameScreen');
                document.getElementById('chatContainer').style.display = 'flex';
                this.handleGameUpdate();
                break;

            case 'message':
                // –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ
                this.displayMessage(data.message);
                break;

            case 'reveal':
                // –ò–≥—Ä–æ–∫ –æ—Ç–∫—Ä—ã–ª –∫–∞—Ä—Ç—É
                if (!this.isHost) {
                    this.gameState.revealedCards = data.revealedCards;
                    this.handleGameUpdate();
                }
                break;

            case 'vote':
                // –ì–æ–ª–æ—Å
                if (this.isHost) {
                    if (!this.gameState.votes) this.gameState.votes = {};
                    this.gameState.votes[data.playerId] = data.vote;
                    this.checkAllVoted();
                }
                break;
        }
    }

    broadcast(data) {
        Object.values(this.connections).forEach(conn => {
            if (conn.open) {
                conn.send(data);
            }
        });
    }

    handleDisconnect(playerId) {
        if (this.isHost && this.players[playerId]) {
            delete this.players[playerId];
            delete this.connections[playerId];
            this.gameState.players = this.players;
            this.broadcast({
                type: 'update',
                gameState: this.gameState
            });
            this.updateLobby();
        }
    }

    generateInviteLink() {
        const data = encodeURIComponent(btoa(JSON.stringify({host: true})));
        const link = `${window.location.origin}${window.location.pathname}?room=${this.roomId}&data=${data}`;
        console.log('Invite link:', link);
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É"
    }

    updateLobby() {
        const playerList = Object.values(this.players);
        const container = document.getElementById('lobbyPlayers');
        
        container.innerHTML = playerList.map(player => `
            <div class="player-item ${player.isHost ? 'host' : ''} ${player.id === this.playerId ? 'current' : ''}">
                <div class="player-avatar" style="background: ${player.avatar.color};">
                    ${player.avatar.letter}
                </div>
                <div class="player-name">${player.name}</div>
                <div class="player-status ${player.isReady ? 'ready' : ''}">
                    ${player.isHost ? 'üëë –•–û–°–¢' : player.isReady ? '‚úì –ì–û–¢–û–í' : '–û–ñ–ò–î–ê–ù–ò–ï'}
                </div>
            </div>
        `).join('');

        this.updatePlayerCount(playerList.length, this.gameState.maxPlayers);

        if (this.isHost) {
            const canStart = playerList.length >= 2;
            const btn = document.getElementById('startGameBtn');
            btn.disabled = !canStart;
            btn.style.opacity = canStart ? '1' : '0.5';
        }
    }

    updatePlayerCount(current, max) {
        document.getElementById('playerCountBadge').textContent = `${current} / ${max}`;
    }

    generateAvatar(name) {
        const colors = [
            '#ff3d3d', '#22c55e', '#3b82f6', '#f59e0b', '#8b5cf6',
            '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#84cc16'
        ];
        return {
            letter: name.charAt(0).toUpperCase(),
            color: colors[Math.floor(Math.random() * colors.length)]
        };
    }

    startGame() {
        const playerList = Object.values(this.players);
        if (playerList.length < 2) {
            this.showModal('–û—à–∏–±–∫–∞', '–ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞');
            return;
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–∞—Ä—Ç—ã –¥–ª—è –≤—Å–µ—Ö
        const cards = {};
        playerList.forEach(player => {
            cards[player.id] = this.generateCards();
        });

        this.gameState = {
            ...this.gameState,
            status: 'playing',
            round: 1,
            phase: 'reveal',
            cards: cards,
            revealedCards: {},
            votes: {},
            eliminated: {},
            messages: []
        };

        this.broadcast({
            type: 'start',
            gameState: this.gameState
        });

        this.showScreen('gameScreen');
        document.getElementById('chatContainer').style.display = 'flex';
        this.handleGameUpdate();
    }

    generateCards() {
        const professions = [
            { title: '–í—Ä–∞—á', desc: '–ú–æ–∂–µ—Ç –ª–µ—á–∏—Ç—å –±–æ–ª–µ–∑–Ω–∏', icon: '‚öïÔ∏è' },
            { title: '–ò–Ω–∂–µ–Ω–µ—Ä', desc: '–†–∞–∑–±–∏—Ä–∞–µ—Ç—Å—è –≤ –º–µ—Ö–∞–Ω–∏–∫–µ', icon: 'üîß' },
            { title: '–§–µ—Ä–º–µ—Ä', desc: '–£–º–µ–µ—Ç –≤—ã—Ä–∞—â–∏–≤–∞—Ç—å –µ–¥—É', icon: 'üåæ' },
            { title: '–í–æ–µ–Ω–Ω—ã–π', desc: '–û–±—É—á–µ–Ω –∑–∞—â–∏—Ç–µ', icon: 'üéñÔ∏è' },
            { title: '–£—á—ë–Ω—ã–π', desc: '–ú–æ–∂–µ—Ç –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å', icon: 'üî¨' },
            { title: '–ü–æ–≤–∞—Ä', desc: '–ì–æ—Ç–æ–≤–∏—Ç –µ–¥—É', icon: 'üë®‚Äçüç≥' },
            { title: '–°—Ç—Ä–æ–∏—Ç–µ–ª—å', desc: '–ú–æ–∂–µ—Ç —Å—Ç—Ä–æ–∏—Ç—å', icon: 'üèóÔ∏è' },
            { title: '–ü—Å–∏—Ö–æ–ª–æ–≥', desc: '–ü–æ–Ω–∏–º–∞–µ—Ç –ª—é–¥–µ–π', icon: 'üß†' }
        ];

        const healths = [
            { title: '–ó–¥–æ—Ä–æ–≤', desc: '–û—Ç–ª–∏—á–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ', icon: 'üí™' },
            { title: '–ü—Ä–æ—Å—Ç—É–¥–∞', desc: '–õ—ë–≥–∫–∞—è –ø—Ä–æ—Å—Ç—É–¥–∞', icon: 'ü§ß' },
            { title: '–ê–ª–ª–µ—Ä–≥–∏—è', desc: '–ê–ª–ª–µ—Ä–≥–∏—è –Ω–∞ –ø—ã–ª—å', icon: 'ü§ß' },
            { title: '–ë–ª–∏–∑–æ—Ä—É–∫–æ—Å—Ç—å', desc: '–ü–ª–æ—Ö–æ–µ –∑—Ä–µ–Ω–∏–µ', icon: 'üëì' },
            { title: '–•—Ä–æ–º–æ—Ç–∞', desc: '–ü—Ä–∏—Ö—Ä–∞–º—ã–≤–∞–µ—Ç', icon: 'ü¶µ' }
        ];

        const hobbies = [
            { title: '–®–∞—Ö–º–∞—Ç—ã', desc: '–°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–µ –º—ã—à–ª–µ–Ω–∏–µ', icon: '‚ôüÔ∏è' },
            { title: '–ë–µ–≥', desc: '–û—Ç–ª–∏—á–Ω–∞—è –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å', icon: 'üèÉ' },
            { title: '–ß—Ç–µ–Ω–∏–µ', desc: '–ó–Ω–∞–Ω–∏—è –∏–∑ –∫–Ω–∏–≥', icon: 'üìö' },
            { title: '–û—Ö–æ—Ç–∞', desc: '–£–º–µ–µ—Ç –¥–æ–±—ã–≤–∞—Ç—å –º—è—Å–æ', icon: 'üéØ' },
            { title: '–†—ã–±–∞–ª–∫–∞', desc: '–ú–æ–∂–µ—Ç –ª–æ–≤–∏—Ç—å —Ä—ã–±—É', icon: 'üé£' }
        ];

        const items = [
            { title: '–ê–ø—Ç–µ—á–∫–∞', desc: '–õ–µ–∫–∞—Ä—Å—Ç–≤–∞', icon: 'üíä' },
            { title: '–û—Ä—É–∂–∏–µ', desc: '–ü–∏—Å—Ç–æ–ª–µ—Ç', icon: 'üî´' },
            { title: '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã', desc: '–ù–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤', icon: 'üß∞' },
            { title: '–ï–¥–∞', desc: '–ö–æ–Ω—Å–µ—Ä–≤—ã', icon: 'ü•´' },
            { title: '–í–æ–¥–∞', desc: '–ó–∞–ø–∞—Å –≤–æ–¥—ã', icon: 'üíß' }
        ];

        const secrets = [
            '–ó–Ω–∞–µ—Ç –æ —Ç–∞–π–Ω–æ–º –≤—Ö–æ–¥–µ',
            '–í–∏–¥–µ–ª –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ—É',
            '–ò–º–µ–µ—Ç —Å–≤—è–∑–∏',
            '–ó–Ω–∞–µ—Ç —Ñ–æ—Ä–º—É–ª—É',
            '–£–º–µ–µ—Ç –≤–∑–ª–∞–º—ã–≤–∞—Ç—å'
        ];

        return {
            profession: this.randomItem(professions),
            health: this.randomItem(healths),
            hobby: this.randomItem(hobbies),
            item: this.randomItem(items),
            secret: this.randomItem(secrets),
            age: Math.floor(Math.random() * 40) + 20,
            gender: Math.random() > 0.5 ? '–ú—É–∂—á–∏–Ω–∞' : '–ñ–µ–Ω—â–∏–Ω–∞',
            ability: '–û–¥–∏–Ω —Ä–∞–∑ –æ—Ç–º–µ–Ω–∏—Ç—å –≥–æ–ª–æ—Å –ø—Ä–æ—Ç–∏–≤ —Å–µ–±—è'
        };
    }

    randomItem(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }

    handleGameUpdate() {
        if (!this.gameState) return;

        const phase = this.gameState.phase;
        const round = this.gameState.round;

        document.getElementById('currentPhase').textContent = this.getPhaseName(phase);
        document.getElementById('roundNumber').textContent = round;
        document.getElementById('roundDescription').textContent = this.getRoundDescription(round);

        if (this.gameState.cards && this.gameState.cards[this.playerId]) {
            this.renderMyCards();
        }

        this.renderOtherPlayers();

        if (phase === 'reveal') {
            document.getElementById('revealBtn').style.display = 'inline-block';
            document.getElementById('readyBtn').style.display = 'none';
        } else if (phase === 'discussion') {
            document.getElementById('revealBtn').style.display = 'none';
            document.getElementById('readyBtn').style.display = 'inline-block';
            this.startTimer(180);
        } else if (phase === 'voting') {
            document.getElementById('revealBtn').style.display = 'none';
            document.getElementById('readyBtn').style.display = 'none';
            this.showVoting();
        }

        if (this.checkGameEnd()) {
            this.endGame();
        }
    }

    getPhaseName(phase) {
        const names = {
            'reveal': '–û—Ç–∫—Ä—ã—Ç–∏–µ',
            'discussion': '–û–±—Å—É–∂–¥–µ–Ω–∏–µ',
            'voting': '–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ'
        };
        return names[phase] || phase;
    }

    getRoundDescription(round) {
        const descriptions = {
            1: '–û—Ç–∫—Ä—ã—Ç–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–π',
            2: '–û—Ç–∫—Ä—ã—Ç–∏–µ –∑–¥–æ—Ä–æ–≤—å—è',
            3: '–û—Ç–∫—Ä—ã—Ç–∏–µ —Ö–æ–±–±–∏',
            4: '–û—Ç–∫—Ä—ã—Ç–∏–µ –±–∞–≥–∞–∂–∞',
            5: '–§–∏–Ω–∞–ª—å–Ω–æ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ'
        };
        return descriptions[round] || '–ì–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ';
    }

    renderMyCards() {
        const cards = this.gameState.cards[this.playerId];
        const revealed = this.gameState.revealedCards[this.playerId] || [];
        const container = document.getElementById('playerCards');

        const cardTypes = [
            { key: 'profession', label: '–ü—Ä–æ—Ñ–µ—Å—Å–∏—è' },
            { key: 'health', label: '–ó–¥–æ—Ä–æ–≤—å–µ' },
            { key: 'hobby', label: '–•–æ–±–±–∏' },
            { key: 'item', label: '–ë–∞–≥–∞–∂' },
            { key: 'secret', label: '–°–µ–∫—Ä–µ—Ç', isSecret: true }
        ];

        container.innerHTML = cardTypes.map(type => {
            const isRevealed = revealed.includes(type.key);
            const card = cards[type.key];
            
            if (type.isSecret) {
                return `
                    <div class="game-card revealed">
                        <div class="card-badge">üîí –°–ï–ö–†–ï–¢</div>
                        <div class="card-title">–¢–∞–π–Ω–∞</div>
                        <div class="card-secret">${cards.secret}</div>
                        <div style="margin-top: 12px; font-size: 0.85rem; color: var(--text-muted);">
                            –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å: ${cards.ability}
                        </div>
                    </div>
                `;
            }

            return `
                <div class="game-card ${isRevealed ? 'revealed' : 'hidden'}" onclick="game.revealCard('${type.key}')">
                    <div class="card-badge">${isRevealed ? card.icon : '‚ùì'} ${type.label.toUpperCase()}</div>
                    <div class="card-content">
                        <div class="card-title">${isRevealed ? card.title : '–°–ö–†–´–¢–û'}</div>
                        <div class="card-description">${isRevealed ? card.desc : '–ù–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å'}</div>
                    </div>
                </div>
            `;
        }).join('');
    }

    renderOtherPlayers() {
        const players = Object.values(this.players || {});
        const container = document.getElementById('otherPlayersGrid');
        
        container.innerHTML = players
            .filter(p => p.id !== this.playerId && p.isAlive)
            .map(player => {
                const revealed = this.gameState.revealedCards[player.id] || [];
                const cards = this.gameState.cards[player.id];
                const lastRevealed = revealed[revealed.length - 1];
                
                return `
                    <div class="player-item">
                        <div class="player-avatar" style="background: ${player.avatar.color};">
                            ${player.avatar.letter}
                        </div>
                        <div class="player-name">${player.name}</div>
                        <div style="margin-top: 8px; font-size: 0.85rem;">
                            ${lastRevealed ? `
                                <div style="color: var(--accent);">${cards[lastRevealed].icon} ${cards[lastRevealed].title}</div>
                            ` : '<span style="color: var(--text-muted);">...</span>'}
                        </div>
                    </div>
                `;
            }).join('');
    }

    revealCard(cardType) {
        if (this.gameState.phase !== 'reveal') return;
        
        const revealed = this.gameState.revealedCards[this.playerId] || [];
        if (!revealed.includes(cardType)) {
            revealed.push(cardType);
            this.gameState.revealedCards[this.playerId] = revealed;
            
            this.broadcast({
                type: 'reveal',
                revealedCards: this.gameState.revealedCards
            });
            
            this.renderMyCards();
            this.checkAllRevealed();
        }
    }

    checkAllRevealed() {
        const players = Object.values(this.players);
        const alivePlayers = players.filter(p => p.isAlive);
        const revealed = this.gameState.revealedCards;
        
        const round = this.gameState.round;
        const cardTypes = ['profession', 'health', 'hobby', 'item'];
        const requiredCard = cardTypes[round - 1];

        const allRevealed = alivePlayers.every(p => {
            const playerRevealed = revealed[p.id] || [];
            return playerRevealed.includes(requiredCard);
        });

        if (allRevealed && this.isHost) {
            setTimeout(() => {
                this.gameState.phase = 'discussion';
                this.broadcast({
                    type: 'update',
                    gameState: this.gameState
                });
                this.handleGameUpdate();
            }, 2000);
        }
    }

    readyForNext() {
        this.players[this.playerId].isReady = true;
        
        if (this.isHost) {
            this.checkAllReady();
        } else {
            this.broadcast({
                type: 'update',
                gameState: this.gameState
            });
        }
    }

    checkAllReady() {
        const alivePlayers = Object.values(this.players).filter(p => p.isAlive);
        const allReady = alivePlayers.every(p => p.isReady);
        
        if (allReady) {
            alivePlayers.forEach(p => p.isReady = false);
            this.gameState.phase = 'voting';
            this.broadcast({
                type: 'update',
                gameState: this.gameState
            });
            this.handleGameUpdate();
        }
    }

    showVoting() {
        const players = Object.values(this.players);
        const alivePlayers = players.filter(p => p.isAlive && p.id !== this.playerId);
        const container = document.getElementById('votingGrid');
        
        document.getElementById('votingSection').style.display = 'block';
        
        container.innerHTML = alivePlayers.map(player => `
            <div class="vote-card" onclick="game.selectVote('${player.id}')" id="vote_${player.id}">
                <div class="player-avatar" style="background: ${player.avatar.color}; width: 48px; height: 48px; margin: 0 auto 12px;">
                    ${player.avatar.letter}
                </div>
                <div class="player-name">${player.name}</div>
            </div>
        `).join('');

        this.startTimer(60);
    }

    selectVote(playerId) {
        document.querySelectorAll('.vote-card').forEach(el => el.classList.remove('selected'));
        document.getElementById('vote_' + playerId).classList.add('selected');
        this.selectedVote = playerId;
    }

    submitVote() {
        if (!this.selectedVote) {
            this.showModal('–û—à–∏–±–∫–∞', '–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä–æ–∫–∞');
            return;
        }

        if (this.isHost) {
            if (!this.gameState.votes) this.gameState.votes = {};
            this.gameState.votes[this.playerId] = this.selectedVote;
            this.checkAllVoted();
        } else {
            this.broadcast({
                type: 'vote',
                playerId: this.playerId,
                vote: this.selectedVote
            });
            document.getElementById('submitVoteBtn').textContent = '–ì–æ–ª–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω';
            document.getElementById('submitVoteBtn').disabled = true;
        }
    }

    checkAllVoted() {
        const alivePlayers = Object.values(this.players).filter(p => p.isAlive);
        const votes = this.gameState.votes || {};
        
        if (Object.keys(votes).length >= alivePlayers.length) {
            this.processVotes(votes);
        }
    }

    processVotes(votes) {
        const voteCounts = {};
        Object.values(votes).forEach(votedId => {
            voteCounts[votedId] = (voteCounts[votedId] || 0) + 1;
        });

        let maxVotes = 0;
        let eliminated = null;
        
        Object.entries(voteCounts).forEach(([playerId, count]) => {
            if (count > maxVotes) {
                maxVotes = count;
                eliminated = playerId;
            }
        });

        if (eliminated) {
            this.players[eliminated].isAlive = false;
            
            if (!this.gameState.eliminated) this.gameState.eliminated = {};
            this.gameState.eliminated[eliminated] = {
                playerId: eliminated,
                playerName: this.players[eliminated].name,
                votes: maxVotes,
                round: this.gameState.round
            };

            const aliveCount = Object.values(this.players).filter(p => p.isAlive).length;
            
            if (aliveCount <= 2 || this.gameState.round >= 5) {
                this.gameState.status = 'ended';
                this.broadcast({
                    type: 'update',
                    gameState: this.gameState
                });
                this.endGame();
            } else {
                this.gameState.round++;
                this.gameState.phase = 'reveal';
                this.gameState.votes = {};
                this.broadcast({
                    type: 'update',
                    gameState: this.gameState
                });
                this.handleGameUpdate();
            }
        }
    }

    checkGameEnd() {
        if (this.gameState.status === 'ended') return true;
        const alive = Object.values(this.players).filter(p => p.isAlive);
        return alive.length <= 2 || this.gameState.round > 5;
    }

    endGame() {
        this.showScreen('resultsScreen');
        
        const survivors = Object.values(this.players).filter(p => p.isAlive);
        const eliminated = this.gameState.eliminated || {};
        
        let html = `
            <div style="margin-bottom: 32px;">
                <h3 style="color: var(--success); font-size: 1.25rem; font-weight: 700; margin-bottom: 16px;">üèÜ –í–´–ñ–ò–í–®–ò–ï</h3>
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 12px;">
                    ${survivors.map(p => `
                        <div class="player-item" style="border-color: var(--success);">
                            <div class="player-avatar" style="background: ${p.avatar.color};">${p.avatar.letter}</div>
                            <div class="player-name">${p.name}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;

        if (Object.keys(eliminated).length > 0) {
            html += `
                <div>
                    <h3 style="color: var(--danger); font-size: 1.25rem; font-weight: 700; margin-bottom: 16px;">üíÄ –ò–°–ö–õ–Æ–ß–Å–ù–ù–´–ï</h3>
                    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 8px;">
                        ${Object.values(eliminated).map(e => `
                            <div class="player-item" style="opacity: 0.6; border-color: var(--danger);">
                                <div class="player-name">${e.playerName}</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">–†–∞—É–Ω–¥ ${e.round} ‚Ä¢ ${e.votes} –≥–æ–ª–æ—Å–æ–≤</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        document.getElementById('resultsContent').innerHTML = html;
    }

    startTimer(seconds) {
        clearInterval(this.timerInterval);
        
        const timerEl = document.getElementById('gameTimer');
        const container = document.getElementById('timerContainer');
        container.style.display = 'flex';
        
        let remaining = seconds;
        
        this.timerInterval = setInterval(() => {
            remaining--;
            
            const mins = Math.floor(remaining / 60);
            const secs = remaining % 60;
            timerEl.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            if (remaining <= 30) timerEl.className = 'timer warning';
            if (remaining <= 10) timerEl.className = 'timer danger';
            
            if (remaining <= 0) {
                clearInterval(this.timerInterval);
                container.style.display = 'none';
            }
        }, 1000);
    }

    sendMessage() {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        
        if (!text) return;
        
        const message = {
            author: this.playerName,
            text: text,
            timestamp: Date.now()
        };
        
        this.displayMessage(message);
        
        this.broadcast({
            type: 'message',
            message: message
        });
        
        input.value = '';
    }

    displayMessage(msg) {
        const container = document.getElementById('chatMessages');
        const div = document.createElement('div');
        div.className = 'chat-message';
        div.innerHTML = `
            <div class="author">${msg.author}</div>
            <div>${msg.text}</div>
        `;
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    leaveRoom() {
        if (this.peer) {
            this.peer.destroy();
        }
        this.returnToMenu();
    }

    returnToMenu() {
        clearInterval(this.timerInterval);
        this.roomId = null;
        this.playerId = null;
        this.isHost = false;
        this.gameState = null;
        this.players = {};
        this.connections = {};
        this.selectedVote = null;
        
        if (this.peer) {
            this.peer.destroy();
            this.peer = null;
        }
        
        document.getElementById('chatContainer').style.display = 'none';
        document.getElementById('timerContainer').style.display = 'none';
        document.getElementById('votingSection').style.display = 'none';
        document.getElementById('revealBtn').style.display = 'none';
        document.getElementById('readyBtn').style.display = 'none';
        
        document.getElementById('createPlayerName').value = '';
        document.getElementById('joinPlayerName').value = '';
        document.getElementById('roomCodeInput').value = '';
        
        // –£–±–∏—Ä–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã URL
        window.history.replaceState({}, '', window.location.pathname);
        
        this.showScreen('mainMenu');
    }

    showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
        this.currentScreen = screenId;
    }

    showModal(title, text) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalText').textContent = text;
        document.getElementById('modal').classList.add('active');
    }

    closeModal() {
        document.getElementById('modal').classList.remove('active');
    }

    showRules() {
        document.getElementById('rulesModal').classList.add('active');
    }

    closeRules() {
        document.getElementById('rulesModal').classList.remove('active');
    }

    toggleChat() {
        const chat = document.getElementById('chatContainer');
        chat.style.height = chat.style.height === '50px' ? '400px' : '50px';
    }
}

// Initialize
const game = new BunkerGame();

// Global functions
function showScreen(screenId) { game.showScreen(screenId); }
function createGame() { game.createGame(); }
function joinGame() { game.joinGame(); }
function startGame() { game.startGame(); }
function leaveRoom() { game.leaveRoom(); }
function revealCard() { game.revealCard(); }
function readyForNext() { game.readyForNext(); }
function submitVote() { game.submitVote(); }
function sendMessage() { game.sendMessage(); }
function closeModal() { game.closeModal(); }
function showRules() { game.showRules(); }
function closeRules() { game.closeRules(); }
function returnToMenu() { game.returnToMenu(); }
function toggleChat() { game.toggleChat(); }
'''

with open('/mnt/kimi/output/bunker-game/app.js', 'w', encoding='utf-8') as f:
    f.write(app_js_free)

print("‚úÖ –ù–æ–≤–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ Firebase —Å–æ–∑–¥–∞–Ω–∞!")
print("üìä –†–∞–∑–º–µ—Ä: {:,} bytes".format(len(app_js_free)))
